{"version":3,"file":"docsify-tabs.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*?) -->`),\n\n    // Matches inner-most tab set by start/end comment\n    // Ex: <!-- tabs:start --> (<!-- tabs:start --><!-- tabs:end -->) <!-- tabs:end -->\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: undefined\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /( *)(<!-+\\s+tabs:\\s*?start\\s+-+>)(?:(?!(<!-+\\s+tabs:\\s*?(?:start|end)\\s+-+>))[\\s\\S])*(<!-+\\s+tabs:\\s*?end\\s+-+>)/,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:(?!replace))/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\nconst storageKeys = {\n    get persist() {\n        return `docsify-tabs.persist.${window.location.pathname}`;\n    },\n    sync: 'docsify-tabs.sync'\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Traverses the element and its parents until it finds a node that matches the\n * provided selector string. Will return itself or the matching ancestor.\n *\n * @param {object} elm\n * @param {string} closestSelectorString\n * @return {(object|null)}\n */\nfunction getClosest(elm, closestSelectorString) {\n    if (Element.prototype.closest) {\n        return elm.closest(closestSelectorString);\n    }\n\n    while (elm) {\n        const isMatch = matchSelector(elm, closestSelectorString);\n\n        if (isMatch) {\n            return elm;\n        }\n\n        elm = elm.parentNode || null;\n    }\n\n    return elm;\n}\n\n/**\n * Checks to see if the element would be selected by the provided selectorString\n *\n * @param {object} elm\n * @param {string} selectorString\n * @return {boolean}\n */\nfunction matchSelector(elm, selectorString) {\n    const matches = Element.prototype.matches ||\n        Element.prototype.msMatchesSelector ||\n        Element.prototype.webkitMatchesSelector;\n\n    return matches.call(elm, selectorString);\n}\n\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content, vm) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, () => codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n    const tempElm  = document.createElement('div');\n\n    let tabBlockMatch = content.match(regex.tabBlockMarkup);\n    let tabIndex = 1;\n\n    // Process each tab set\n    while (tabBlockMatch) {\n        let tabBlockOut = tabBlockMatch[0];\n\n        const tabBlockIndent = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlockOut);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlockOut);\n\n        let tabMatch;\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlockOut) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlockOut) : null)) !== null) {\n                // Process tab title as markdown\n                // Ex: <!-- tab:**Bold** and <span style=\"color: red;\">red</span> -->\n                tempElm.innerHTML = tabMatch[2].trim() ? vm.compiler.compile(tabMatch[2]).replace(/<\\/?p>/g, '') : `Tab ${tabIndex}`;\n\n                const tabTitle = tempElm.innerHTML;\n                const tabContent = (tabMatch[3] || '').trim();\n                const tabData = (\n                    tempElm.textContent ||\n                    (tempElm.firstChild.getAttribute('alt') || tempElm.firstChild.getAttribute('src'))\n                ).trim().toLowerCase();\n\n                // Use replace function to avoid regex special replacement\n                // strings being processed ($$, $&, $`, $', $n)\n                tabBlockOut = tabBlockOut.replace(tabMatch[0], () => [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabData}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabData}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n\n                tabIndex++;\n            }\n        }\n\n        tabBlockOut = tabBlockOut.replace(tabBlockStart, () => tabStartReplacement);\n        tabBlockOut = tabBlockOut.replace(tabBlockEnd, () => tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], () => tabBlockOut);\n\n        tabBlockMatch = content.match(regex.tabBlockMarkup);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, () => codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, () => tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks         = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStoragePersist = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n    const tabStorageSync    = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n    setActiveTabFromAnchor();\n\n    tabBlocks.forEach((tabBlock, index) => {\n        let activeButton = Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, `.${classNames.tabButtonActive}`))[0];\n\n        if (!activeButton) {\n            if (settings.sync && tabStorageSync.length) {\n                activeButton = tabStorageSync\n                    .map(label => Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${label}\"]`))[0])\n                    .filter(elm => elm)[0];\n            }\n\n            if (!activeButton && settings.persist) {\n                activeButton = tabBlock.querySelector(Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`))[0]);\n            }\n\n            activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n            activeButton && activeButton.classList.add(classNames.tabButtonActive);\n        }\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n    const activeButton = getClosest(elm, `.${classNames.tabButton}`);\n\n    if (activeButton) {\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.children).filter(elm => matchSelector(elm, 'button'));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (!_isMatchingTabSync) {\n            if (settings.persist) {\n                const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n                const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n                const tabStorage    = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n\n                tabStorage[tabBlockIndex] = activeButtonLabel;\n                sessionStorage.setItem(storageKeys.persist, JSON.stringify(tabStorage));\n            }\n\n            if (settings.sync) {\n                const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n                const tabStorage       = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n                tabButtonMatches.forEach(tabButtonMatch => {\n                    setActiveTab(tabButtonMatch, true);\n                });\n\n                // Maintain position in viewport when tab group's offset changes\n                window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n                // Remove existing label if not first in array\n                if (tabStorage.indexOf(activeButtonLabel) > 0) {\n                    tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n                }\n\n                // Add label if not already in first position\n                if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n                    tabStorage.unshift(activeButtonLabel);\n                    sessionStorage.setItem(storageKeys.sync, JSON.stringify(tabStorage));\n                }\n            }\n        }\n    }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n    const anchorID              = decodeURIComponent((window.location.hash.match(/(?:id=)([^&]+)/) || [])[1]);\n    const anchorSelector        = anchorID && `.${classNames.tabBlock} #${anchorID}`;\n    const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n    if (isAnchorElmInTabBlock) {\n        const anchorElm = document.querySelector(`#${anchorID}`);\n\n        let tabContent;\n\n        if (anchorElm.closest) {\n            tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n        }\n        else {\n            tabContent = anchorElm.parentNode;\n\n            while (tabContent !== document.body && !tabContent.classList.contains(`${classNames.tabContent}`)) {\n                tabContent = tabContent.parentNode;\n            }\n        }\n\n        setActiveTab(tabContent.previousElementSibling);\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs = false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content, vm);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function handleTabClick(evt) {\n            setActiveTab(evt.target);\n        });\n\n        window.addEventListener('hashchange', setActiveTabFromAnchor, false);\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (Object.prototype.hasOwnProperty.call(settings, key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            (window.$docsify.plugins || []),\n            docsifyTabs\n        );\n    }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","concat","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","storageKeys","window","location","pathname","getClosest","elm","closestSelectorString","Element","prototype","closest","isMatch","matchSelector","parentNode","selectorString","matches","msMatchesSelector","webkitMatchesSelector","call","renderTabsStage1","content","vm","codeBlockMatch","match","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tempElm","tabBlockMatch","tabIndex","_loop","tabBlockOut","tabBlockIndent","tabBlockStart","tabBlockEnd","hasTabComments","test","hasTabHeadings","tabMatch","tabStartReplacement","tabEndReplacement","join","_loop2","innerHTML","trim","compiler","compile","tabTitle","tabData","textContent","getAttribute","toLowerCase","exec","forEach","renderTabsStage2","html","tabReplaceMatch","_loop3","tabComment","tabReplacement","setDefaultTabs","querySelector","tabBlocks","Array","apply","querySelectorAll","tabStoragePersist","JSON","parse","sessionStorage","getItem","tabStorageSync","setActiveTabFromAnchor","index","activeButton","children","filter","length","label","classList","add","setActiveTab","_isMatchingTabSync","activeButtonLabel","tabButtons","tabBlockOffset","offsetTop","buttonElm","remove","tabBlockIndex","indexOf","tabStorage","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","anchorID","decodeURIComponent","hash","anchorSelector","isAnchorElmInTabBlock","anchorElm","body","contains","previousElementSibling","docsifyTabs","hook","hasTabs","beforeEach","afterEach","next","doneEach","mounted","addEventListener","handleTabClick","evt","target","$docsify","tabs","Object","keys","key","hasOwnProperty","version","pkgVersion","plugins"],"mappings":";;;;;;;;;;IAAA,SAASA,YAAYC,KAAKC;QACxB,IAAKA,aAAa,GAAIA,MAAM,CAAA;QAC5B,IAAIC,WAAWD,IAAIC;QAEnB,KAAKF,cAAcG,aAAa,aAAa;YAAE;AAAS;QAExD,IAAIC,OAAOD,SAASC,QAAQD,SAASE,qBAAqB,QAAQ;QAClE,IAAIC,QAAQH,SAASI,cAAc;QACnCD,MAAME,OAAO;QAEb,IAAIN,aAAa,OAAO;YACtB,IAAIE,KAAKK,YAAY;gBACnBL,KAAKM,aAAaJ,OAAOF,KAAKK;AAC/B,mBAAM;gBACLL,KAAKO,YAAYL;AAClB;AACF,eAAM;YACLF,KAAKO,YAAYL;AAClB;QAED,IAAIA,MAAMM,YAAY;YACpBN,MAAMM,WAAWC,UAAUb;AAC5B,eAAM;YACLM,MAAMK,YAAYR,SAASW,eAAed;AAC3C;AACF;;;;;ICjBD,IAAMe,qBAAqB;IAC3B,IAAMC,aAAa;QACfC,eAAiB;QACjBC,UAAiB;QACjBC,WAAiB;QACjBC,iBAAiB;QACjBC,YAAiB;;IAErB,IAAMC,QAAQ;QAGVC,YAAY;QAKZC,sBAAsB,IAAIC,OAAJ,WAAAC,OAAmBX,oBAR/B;QAiBVY,gBAAgB;QAMhBC,kBAAkB;QAMlBC,kBAAkB;;IAEtB,IAAMC,WAAW;QACbC,SAAa;QACbC,MAAa;QACbC,OAAa;QACbC,aAAa;QACbC,aAAa;;IAGjB,IAAMC,cAAc;QACZL;YACA,OAAA,wBAAAL,OAA+BW,OAAOC,SAASC;AAFnC;QAIhBP,MAAM;;IAcV,SAASQ,WAAWC,KAAKC;QACrB,IAAIC,QAAQC,UAAUC,SAAS;YAC3B,OAAOJ,IAAII,QAAQH;AACtB;QAED,OAAOD,KAAK;YACR,IAAMK,UAAUC,cAAcN,KAAKC;YAEnC,IAAII,SAAS;gBACT,OAAOL;AACV;YAEDA,MAAMA,IAAIO,cAAc;AAC3B;QAED,OAAOP;AACV;IASD,SAASM,cAAcN,KAAKQ;QACxB,IAAMC,UAAUP,QAAQC,UAAUM,WAC9BP,QAAQC,UAAUO,qBAClBR,QAAQC,UAAUQ;QAEtB,OAAOF,QAAQG,KAAKZ,KAAKQ;AAC5B;IAUD,SAASK,iBAAiBC,SAASC;QAC/B,IAAMC,iBAAmBF,QAAQG,MAAMpC,MAAMC,eAAe;QAC5D,IAAMoC,mBAAmBF,eAAeG,KAAI,SAACC,MAAMC;YAC/C,IAAMC,aAAqBhD,WAAAA,OAAAA,yCAA+B+C,GAA1C;YAKhBP,UAAUA,QAAQS,QAAQH,OAAM;gBAAA,OAAME;AAAN;YAEhC,OAAOA;AACV;QACD,IAAME,WAAWnC,SAASG,QAAWjB,GAAAA,OAAAA,WAAWE,UAAaY,MAAAA,OAAAA,SAASG,SAAU;QAChF,IAAMiC,UAAW/D,SAASI,cAAc;QAExC,IAAI4D,gBAAgBZ,QAAQG,MAAMpC,MAAMK;QACxC,IAAIyC,WAAW;QAhBoB,IAAAC,QAAA,SAAAA;YAoB/B,IAAIC,cAAcH,cAAc;YAEhC,IAAMI,iBAAiBJ,cAAc;YACrC,IAAMK,gBAAiBL,cAAc;YACrC,IAAMM,cAAiBN,cAAc;YACrC,IAAMO,iBAAiB5C,SAASI,eAAeZ,MAAMM,iBAAiB+C,KAAKL;YAC3E,IAAMM,iBAAiB9C,SAASK,eAAeb,MAAMO,iBAAiB8C,KAAKL;YAE3E,IAAIO,gBAAJ;YACA,IAAIC,sBAAsB;YAC1B,IAAIC,oBAAsB;YAE1B,IAAIL,kBAAkBE,gBAAgB;gBAClCE,sBAA8B/D,WAAAA,OAAAA,oBAAkC,iBAAAW,OAAA,EAACV,WAAWE,UAAU+C,WAAUe,KAAK,MAArG;gBACAD,gCAAyBR,gBAAR,YAAA7C,OAA8BX,oBAA9B;gBAFiB,IAAAkE,SAAA,SAAAA;oBAQ9Bf,QAAQgB,YAAYL,SAAS,GAAGM,SAAS3B,GAAG4B,SAASC,QAAQR,SAAS,IAAIb,QAAQ,WAAW,MAAzE,OAAAtC,OAAsF0C;oBAE1G,IAAMkB,WAAWpB,QAAQgB;oBACzB,IAAM7D,cAAcwD,SAAS,MAAM,IAAIM;oBACvC,IAAMI,WACFrB,QAAQsB,eACPtB,QAAQzD,WAAWgF,aAAa,UAAUvB,QAAQzD,WAAWgF,aAAa,QAC7EN,OAAOO;oBAITpB,cAAcA,YAAYN,QAAQa,SAAS,KAAI;wBAAA,OAAM,EAC5CN,KAAAA,OAAAA,gBAAsBxD,YAAAA,OAAAA,+CAAqCC,WAAWG,WAD1B,gBAAAO,OACkD6D,SAAYD,MAAAA,OAAAA,UAC1Gf,qBAAAA,KAAAA,OAAAA,mCAAsBxD,oBAFsB,iBAAAW,OAEYV,WAAWK,YAFvB,wBAAAK,OAEwD6D,SAFxD,cAAA,OAAA7D,OAG1C6C,gBAAiBlD,OAAAA,aACjBkD,OAAAA,OAAAA,mCAAsBxD,oBAJoB,oBAKnDiE,KAAK;AALwC;oBAO/CZ;AA1B8B;gBAKlC,QAAQS,YAAY/C,SAASI,cAAcZ,MAAMM,iBAAiB+D,KAAKrB,eAAe,UAAUxC,SAASK,cAAcb,MAAMO,iBAAiB8D,KAAKrB,eAAe,WAAW,MAAM;oBAAAW;AAsBlL;AACJ;YAEDX,cAAcA,YAAYN,QAAQQ,gBAAe;gBAAA,OAAMM;AAAN;YACjDR,cAAcA,YAAYN,QAAQS,cAAa;gBAAA,OAAMM;AAAN;YAC/CxB,UAAUA,QAAQS,QAAQG,cAAc,KAAI;gBAAA,OAAMG;AAAN;YAE5CH,gBAAgBZ,QAAQG,MAAMpC,MAAMK;AAlEL;QAmBnC,OAAOwC,eAAe;YAAAE;AAnBa;QAsEnCV,iBAAiBiC,SAAQ,SAAC/B,MAAMC;YAC5BP,UAAUA,QAAQS,QAAQH,OAAM;gBAAA,OAAMJ,eAAeK;AAArB;;QAGpC,OAAOP;AACV;IASD,SAASsC,iBAAiBC;QACtB,IAAIC;QADwB,IAAAC,SAAA,SAAAA;YAIxB,IAAMC,aAAiBF,gBAAgB;YACvC,IAAMG,iBAAiBH,gBAAgB,MAAM;YAE7CD,OAAOA,KAAK9B,QAAQiC,aAAY;gBAAA,OAAMC;AAAN;AAPR;QAG5B,QAAQH,kBAAkBzE,MAAME,qBAAqBmE,KAAKG,WAAW,MAAM;YAAAE;AAK1E;QAED,OAAOF;AACV;IAOD,SAASK;QACL,IAAMlF,gBAAoBd,SAASiG,cAAkBpF,IAAAA,OAAAA,WAAWC;QAChE,IAAMoF,YAAoBpF,gBAAgBqF,MAAMC,MAAM,MAAMtF,cAAcuF,4BAAqBxF,WAAWE,cAAe;QACzH,IAAMuF,oBAAoBC,KAAKC,MAAMC,eAAeC,QAAQzE,YAAYL,aAAa;QACrF,IAAM+E,iBAAoBJ,KAAKC,MAAMC,eAAeC,QAAQzE,YAAYJ,UAAU;QAElF+E;QAEAV,UAAUT,SAAQ,SAAC1E,UAAU8F;YACzB,IAAIC,eAAeX,MAAMC,MAAM,MAAMrF,SAASgG,UAAUC,QAAO,SAAA1E;gBAAG,OAAIM,cAAcN,gBAASzB,WAAWI;gBAAoB;YAE5H,KAAK6F,cAAc;gBACf,IAAInF,SAASE,QAAQ8E,eAAeM,QAAQ;oBACxCH,eAAeH,eACVlD,KAAI,SAAAyD;wBAAK,OAAIf,MAAMC,MAAM,MAAMrF,SAASgG,UAAUC,QAAO,SAAA1E;4BAAG,OAAIM,cAAcN,KAAD,IAAAf,OAAUV,WAAWG,WAAuBkG,eAAAA,OAAAA,OAA7D;4BAAyE;AAA5H,wBACTF,QAAO,SAAA1E;wBAAG,OAAIA;wBAAK;AAC3B;gBAED,KAAKwE,gBAAgBnF,SAASC,SAAS;oBACnCkF,eAAe/F,SAASkF,cAAcE,MAAMC,MAAM,MAAMrF,SAASgG,UAAUC,QAAO,SAAA1E;wBAAG,OAAIM,cAAcN,KAAD,IAAAf,OAAUV,WAAWG,WAArB,eAAAO,OAA4C+E,kBAAkBO,QAA/E;wBAA4F;AACpL;gBAEDC,eAAeA,gBAAgB/F,SAASkF,cAAkBpF,IAAAA,OAAAA,WAAWG;gBACrE8F,gBAAgBA,aAAaK,UAAUC,IAAIvG,WAAWI;AACzD;;AAER;IAQD,SAASoG,aAAa/E;QAAiC,IAA5BgF,yFAAqB;QAC5C,IAAMR,eAAezE,WAAWC,KAASzB,IAAAA,OAAAA,WAAWG;QAEpD,IAAI8F,cAAc;YACd,IAAMS,oBAAoBT,aAAaxB,aAAa;YACpD,IAAMxE,gBAAoBd,SAASiG,cAAkBpF,IAAAA,OAAAA,WAAWC;YAChE,IAAMC,WAAoB+F,aAAajE;YACvC,IAAM2E,aAAoBrB,MAAMC,MAAM,MAAMrF,SAASgG,UAAUC,QAAO,SAAA1E;gBAAG,OAAIM,cAAcN,KAAK;AAAvB;YACzE,IAAMmF,iBAAoB1G,SAAS2G;YAEnCF,WAAW/B,SAAQ,SAAAkC;gBAAS,OAAIA,UAAUR,UAAUS,OAAO/G,WAAWI;;YACtE6F,aAAaK,UAAUC,IAAIvG,WAAWI;YAEtC,KAAKqG,oBAAoB;gBACrB,IAAI3F,SAASC,SAAS;oBAClB,IAAMsE,YAAgBpF,gBAAgBqF,MAAMC,MAAM,MAAMtF,cAAcuF,4BAAqBxF,WAAWE,cAAe;oBACrH,IAAM8G,gBAAgB3B,UAAU4B,QAAQ/G;oBACxC,IAAMgH,aAAgBxB,KAAKC,MAAMC,eAAeC,QAAQzE,YAAYL,aAAa;oBAEjFmG,WAAWF,iBAAiBN;oBAC5Bd,eAAeuB,QAAQ/F,YAAYL,SAAS2E,KAAK0B,UAAUF;AAC9D;gBAED,IAAIpG,SAASE,MAAM;oBACf,IAAMqG,mBAAmBpH,gBAAgBqF,MAAMC,MAAM,MAAMtF,cAAcuF,iBAAd,IAAA9E,OAAmCV,WAAWG,iCAAuBuG,mBAArE,UAA+F;oBAC1J,IAAMQ,cAAmBxB,KAAKC,MAAMC,eAAeC,QAAQzE,YAAYJ,UAAU;oBAEjFqG,iBAAiBzC,SAAQ,SAAA0C;wBACrBd,aAAac,gBAAgB;AAChC;oBAGDjG,OAAOkG,SAAS,GAAG,KAAKX,iBAAiB1G,SAAS2G;oBAGlD,IAAIK,YAAWD,QAAQP,qBAAqB,GAAG;wBAC3CQ,YAAWM,OAAON,YAAWD,QAAQP,oBAAoB;AAb9C;oBAiBf,IAAIQ,YAAWD,QAAQP,uBAAuB,GAAG;wBAC7CQ,YAAWO,QAAQf;wBACnBd,eAAeuB,QAAQ/F,YAAYJ,MAAM0E,KAAK0B,UAAUF;AAC3D;AACJ;AACJ;AACJ;AACJ;IAKD,SAASnB;QACL,IAAM2B,WAAwBC,oBAAoBtG,OAAOC,SAASsG,KAAKlF,MAAM,qBAAqB,IAAI;QACtG,IAAMmF,iBAAwBH,YAAQ,IAAAhH,OAAQV,WAAWE,UAAawH,MAAAA,OAAAA;QACtE,IAAMI,wBAAwBJ,YAAYvI,SAASiG,cAAcyC;QAEjE,IAAIC,uBAAuB;YACvB,IAAMC,YAAY5I,SAASiG,cAAT,IAAA1E,OAA2BgH;YAE7C,IAAIrH;YAEJ,IAAI0H,UAAUlG,SAAS;gBACnBxB,aAAa0H,UAAUlG,mBAAY7B,WAAWK;AACjD,mBACI;gBACDA,aAAa0H,UAAU/F;gBAEvB,OAAO3B,eAAelB,SAAS6I,SAAS3H,WAAWiG,UAAU2B,SAArB,GAAAvH,OAAiCV,WAAWK,cAAe;oBAC/FA,aAAaA,WAAW2B;AAC3B;AACJ;YAEDwE,aAAanG,WAAW6H;AAC3B;AACJ;IAKD,SAASC,YAAYC,MAAM5F;QACvB,IAAI6F,UAAU;QAEdD,KAAKE,YAAW,SAAS/F;YACrB8F,UAAU/H,MAAMK,eAAegD,KAAKpB;YAEpC,IAAI8F,SAAS;gBACT9F,UAAUD,iBAAiBC,SAASC;AACvC;YAED,OAAOD;;QAGX6F,KAAKG,WAAU,SAASzD,MAAM0D;YAC1B,IAAIH,SAAS;gBACTvD,OAAOD,iBAAiBC;AAC3B;YAED0D,KAAK1D;;QAGTsD,KAAKK,UAAS;YACV,IAAIJ,SAAS;gBACTlD;AACH;;QAGLiD,KAAKM,SAAQ;YACT,IAAMzI,gBAAgBd,SAASiG,cAAkBpF,IAAAA,OAAAA,WAAWC;YAE5DA,iBAAiBA,cAAc0I,iBAAiB,UAAS,SAASC,eAAeC;gBAC7ErC,aAAaqC,IAAIC;AACpB;YAEDzH,OAAOsH,iBAAiB,cAAc5C,wBAAwB;;AAErE;IAGD,IAAI1E,QAAQ;QACRA,OAAO0H,WAAW1H,OAAO0H,YAAY,CAAA;QAGrC1H,OAAO0H,SAASC,OAAO3H,OAAO0H,SAASC,QAAQ;QAG/CC,OAAOC,KAAK7H,OAAO0H,SAASC,MAAMpE,SAAQ,SAAAuE;YACtC,IAAIF,OAAOrH,UAAUwH,eAAe/G,KAAKvB,UAAUqI,MAAM;gBACrDrI,SAASqI,OAAO9H,OAAO0H,SAASC,KAAKG;AACxC;AACJ;QAGD9H,OAAO0H,SAASC,KAAKK,UAAUC;QAG/B,IAAIxI,SAASI,eAAeJ,SAASK,aAAa;YAC9CE,OAAO0H,SAASQ,UAAU,GAAG7I,OACxBW,OAAO0H,SAASQ,WAAW,IAC5BpB;AAEP;AACJ;"}